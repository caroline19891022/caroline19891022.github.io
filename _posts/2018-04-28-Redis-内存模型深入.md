---
layout: post
title: "Redis 内存模型深入"
date: 2018-04-28 17:49:00 +0800
tags: [redis]
---

Redis 内存模型深入

## Redis 内存统计
* 使用`redis-cli -h {hostname} -p {port}`连接 redis
* 连接成功，使用`info memory`查看内存信息
```
used_memory:9451784  #分配器分配的内存总量
used_memory_human:9.01M  #上一行的人类看得懂的方式
used_memory_rss:12984320  #Redis进程占据操作系统的内存
used_memory_rss_human:12.38M
used_memory_peak:19658408
used_memory_peak_human:18.75M
used_memory_peak_perc:48.08%
used_memory_overhead:7657748
used_memory_startup"1424544
used_memory_dataset:1794036
used_memory_dataset_perc:22.35%
total_system_memory:16862044160
total_system_memory_human:15.70G
used_memory_lua:37888
used_memory_lua_human:37.00K
maxmemory:0
maxmemory_human:0B
maxmemory_policy:noeviction
mem_fragmentation_ratio:1.37  #内存碎片比率
mem_allocator:jemalloc-4.0.3 # 内存分配器
active_defrag_running:0
lazyfree_pending_objects:0
```

* used_memory: Redis 分配的内存总量（包括使用的虚拟内存）；
* used_memory_rss: Redis 进程占据操作系统的内存，和 top 以及 ps 命令看到的是一样的；
即：used_memory + 进程运行内存 + 内存碎片 - 虚拟内存；
* mem_fragmentation_ratio: 内存碎片比，即 used_memory_rss/used_memory 。
小于1时说明内存不够用了，使用了虚拟内存；
越大说明内存碎片比越大，内存分配器是 jemalloc 的时候1.03是个较健康的状态。
* mem_allocator: 内存分配器。包括jemalloc(default)、libc、tcmalloc。

## 内存划分
1. 数据
值包括5种对外提供的类型：字符串、哈希、列表、集合、有序集合。  
Redis 内部对每种类型的值可能有2种或更多的内部编码实现。  
数据会统计在 used_memory 中。
2. 进程本身需要的内存
Redis 主进程本身运行，代码、常量池等需要占用的内存。  
不属于内存分配器分配，不会统计在 used_memory，但会统计在 used_memory_rss 中。
3. 缓冲内存
包括客户端缓冲区、复制积压缓冲区、AOF 缓冲区。  
由分配器分配，统计在 used_memory 和 used_memory_rss 中。
4. 内存碎片
内存碎片是 Redis 在分配、回收物理内存过程中产生的。  
如果对数据更改频繁，且数据之间的大小相差很大，会形成内存碎片。  
不统计在 used_memory 中，但会统计在 used_memory_rss 中。  
可以通过安全重启减小内存碎片。  

## Redis 数据存储细节
### 概述
当 Redis set hello world 的时候，它干了啥
![what Redis have done when set ‘hello world’](images/redis-dictEntry.png)

-> **dictEntry** 每个键值对都有一个 dictEntry，里面包含指向 key 和 value 的指针；next 指向下一个 dictEntry，与本 key-value 无关。  
-> **key** 存储于 SDS 结构中  
```
SDS: 
struct sdsheader {
     int len;
     int free;
     char buf[];
}
```  

-> **redisObject** 不管什么类型的 value 都存储在 redisObject 中。redisObject 中的 type 字段指明了 value 对象的类型，ptr 指向对象所在地址。而 redisObject 中的字符串对象仍然是通过 SDS 存储的。  
-> **jemalloc** 以上对象都需要内存分配器分配内存进行存储。

### redisObject
redisObject 对象非常重要，Redis 对象的类型、内部编码、内存回收、共享对象等功能，都需要 redisObject 支持。  
redisObject 的定义如下（不同版本的 Redis 可能稍有不同）：  
```c
typedef struct redisObject {
    unsigned type:4;
    unsigned encoding:4;
    unsigned lru:REDIS_LRU_BITS;
    int refcount;
    void *ptr;
} robj;
```
一个 redisObject 对象大小为 16 Bype。

* type: 对象类型
包括 REDIS_STRING、REDIS_LIST、REDIS_HASH、REDIS_SET、REDIS_ZSET。
* encoding: 对象的内部编码
每种数据类型都有至少两种 encoding。比如字符串有 int/embstr/raw 这三种。目的是优化性能。  
`object encoding {key}` 可查看对象编码方式。
* lru: 对象最后一次被命令程序访问的时间
当前时间 - 最后访问时间(ms)。  
`object idletime {key}` 查看对象空转时间，且不改变对象 lru 值。  
与 Redis 内存回收有关。如果 Redis 打开了 maxmemory 选项，且内存回收算法选择了 volatile-lru 或 allkeys-lru，会优先释放空转时间最长的对象。  

* refcount: 对象引用次数
refcount 主要用于对象的引用计数和内存回收。  
当创建新对象时，refcount 初始化为 1；值为 0 时，则该对象内存被释放。  
多次被引用的对象称为**共享对象**，目前只支持整数值的字符串对象。  
Redis 服务器在初始化时，会创建 10000 个字符串对象，为 0-9999 的整数值，Redis 可直接使用这些共享对象。  
关于此特性的调优考虑：尽可能使用 0/1 而非 Y/N。  
`object refcount {key}` 查看对象 value 引用次数。  

* ptr 数据指针  
指向 value 值。  



